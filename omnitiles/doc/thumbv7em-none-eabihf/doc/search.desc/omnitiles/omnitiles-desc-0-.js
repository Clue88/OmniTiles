searchState.loadedDescShard("omnitiles", 0, "OmniTiles Firmware\nChip-level / Board-level Drivers\nHardware Abstraction Layer (HAL‐level board support)\nHigh-level CAN motor control for the SteadyWin GIM6010-48 …\nDRV8873-Q1 SPI motor driver.\nHigh-level motor abstraction for DRV8873 SPI driver with a …\nHigh-level CAN motor for a single driver instance, …\nError type for <code>CanMotor</code> operations.\nResponse frame contained no data bytes.\nPayload too long for a single CAN data frame (max 8 bytes …\nReceive-side CAN error.\nTX mailbox or transmit failure.\nResponse had a different command code than expected.\nClear any latched faults.\nTurn off motor output. The motor enters a free state and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new handle for this motor address.\nRead back the real-time motor speed in rpm.\nCommand the motor in speed control mode with a setpoint in …\nDRV8873 driver bound to a specific chip-select pin.\nResponse of a single SPI transaction:\nStatus byte returned in the upper 8 bits of SDO.\nRelease the chip-select pin.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a driver from an active-low chip-select pin.\nRead a register and return the response (status + register …\nSend a 16-bit word and receive the status + data bytes.\nWrite a register and return the response (status + current …\nLogical drive direction for the motor.\nHigh-level motor that combines a DRV8873 driver IC (SPI + …\nDisable the motor output stage (coast or brake, depending …\nEnable the motor output stage.\nExpose the underlying encoder if needed for advanced usage.\nMutable access to the encoder.\nTear down this motor and return its constituent parts.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConfigure the DRV8873 into a known safe operating mode.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new motor from its DRV8873 driver and TIM2 …\nEncoder position converted to revolutions (float).\nRaw encoder position in ticks, centered around 0.\nRead the current status flags (OTW, UVLO, OCP, etc.).\nCommand the motor with a desired direction and duty cycle.\nReset the encoder position to zero.\nAbstraction layer for CAN on STM32F7 using bxcan.\nQuadrature encoder support using STM32F7 timers in encoder …\nAbstraction layer for an LED driven by an STM32F7 pin.\nCentral definition of all STM32F777 pin assignments used …\nAbstraction layer for SPI on STM32F7.\nAbstraction layer for a serial USART connection from an …\nWrapper around a bxcan CAN instance built from a HAL CAN …\nConfigure a single filter bank to accept all frames into …\nConsume the wrapper and get back the underlying HAL CAN …\nReturns the argument unchanged.\nAccess the underlying bxcan instance for advanced …\nCalls <code>U::from(self)</code>.\nCreate and enable a bxcan instance from a HAL CAN …\nBlocking receive of a frame.\nTransmit a data frame with a standard 11-bit ID.\nTransmit a pre-built CAN frame.\nConsume the wrapper and return the underlying timer …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInterpret the counter as a signed 16-bit position.\nInterpret the counter as a signed 32-bit position.\nRead the raw 32-bit counter value.\nRead the raw 16-bit counter value.\nReset the encoder position to zero.\nReset the encoder position to zero.\nConfigure TIM2 as a quadrature encoder with full 32-bit …\nConfigure TIM3 as a quadrature encoder with full 16-bit …\nWhether the LED is driven active-high or active-low on the …\nLED abstraction that remembers its active level and last …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an LED wrapper, initializing it to OFF.\nDrive the LED logically ON (true) or OFF (false).\nAll board pins. Construct this once at startup using:\nCAN1 bus pins\nCAN2 bus pins\nChip-select and digital I/O for DRV8873 drivers\nTIM2/TIM3 Quadrature Encoder Inputs\nLED outputs\nSPI4 SCK/MISO/MOSI\nUSART1 TX/RX\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate all named pins from raw GPIO peripherals.\nManual chip-select line, active-low, generic over any GPIO …\nWrapper around an enabled HAL SPI instance (8-bit words).\nCreate an active-low chip select and set to the inactive …\nDeassert the chip select.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRead a byte, sending 0x00.\nAssert the chip select.\nPerform a blocking, full-duplex of one byte.\nTransfer a byte buffer in-place.\nSend a byte, ignoring the response.\nBlock until the hardware TX FIFO/drain is flushed.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWrite string and CRLF terminator.")