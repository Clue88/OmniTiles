searchState.loadedDescShard("omnitiles", 0, "OmniTiles Firmware\nDevice-Specific Drivers\nHardware Abstraction Layer (HAL‐level board support)\nMotor control over CAN for SteadyWin GIM6010-48 with a …\nDRV8873-Q1 SPI motor driver.\nMotor abstraction for DRV8873 SPI driver with a TIM2 …\nHigh-level CAN motor for a single driver instance, …\nError type for <code>CanMotor</code> operations.\nResponse frame contained no data bytes.\nPayload too long for a single CAN data frame (max 8 bytes …\nReceive-side CAN error.\nTX mailbox or transmit failure.\nResponse had a different command code than expected.\nClear any latched faults.\nTurn off motor output. The motor enters a free state and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new handle for this motor address.\nRead back the real-time motor speed in rpm.\nCommand the motor in speed control mode with a setpoint in …\nDIAG status register.\nDRV8873 driver bound to a specific chip-select pin.\nFAULT status register.\nResponse of a single SPI transaction:\nStatus byte returned in the upper 8 bits of SDO.\nCharge-pump undervoltage fault condition.\nCharge-pump undervoltage fault condition.\nGlobal FAULT status register. Complements the nFAULT pin.\nRelease the chip-select pin.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCurrent regulation status of half bridge 1.\nCurrent regulation status of half bridge 2.\nConstruct a driver from an active-low chip-select pin.\nOvercurrent condition.\nOvercurrent condition.\nOvercurrent fault on the high-side FET of half bridge 1.\nOvercurrent fault on the high-side FET of half bridge 2.\nOvercurrent fault on the low-side FET of half bridge 1.\nOvercurrent fault on the low-side FET of half bridge 2.\nOpen-load detection on half bridge 1.\nOpen-load detection on half bridge 2.\nOpen-load detection.\nOpen-load detection.\nOvertemperature warning.\nOvertemperature warning.\nRead the DIAG register and parse into a <code>Diag</code> struct.\nRead the FAULT register and parse into a <code>Fault</code> struct.\nRead a register and return the response (status + register …\nSend a 16-bit word and receive the status + data bytes.\nOvercurrent shutdown.\nOvercurrent shutdown.\nUVLO fault condition.\nUVLO fault condition.\nWrite a register and return the response (status + current …\nLogical drive direction / mode for the H-bridge.\nMotor abstraction that combines a DRV8873 driver, four …\nApply brakes.\nCoast (this sets outputs to HiZ).\nDisable the motor and coast.\nAccess the underlying DRV8873 driver for advanced SPI …\nEnable the motor and wake the driver if in sleep.\nExpose the underlying encoder.\nMutable access to the encoder.\nDrive the motor forward.\nTear down this motor and return its constituent parts.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialize and set base configuration for the DRV8873.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new <code>SpiMotor</code>.\nEncoder position converted to revolutions.\nRaw encoder position in ticks (signed).\nRead the DIAG status register.\nRead the FAULT status register.\nDrive the motor in reverse.\nPut the driver into sleep mode.\nCompute a target tick position for a relative move in …\nCompute a target tick position for a relative move from …\nConvert a number of revolutions into encoder ticks.\nWake the driver from sleep mode.\nReset the encoder position to zero.\nController Area Network (CAN) abstraction layer.\nQuadrature encoder support via STM32F7 timers in encoder …\nLED abstraction layer.\nPin definitions for STM32F777 MCU for OmniTiles.\nPin definitions for the NUCLEO-F767ZI development board.\nSerial Peripheral Interface (SPI) abstraction layer.\nUSART abstraction layer.\nWrapper around a bxcan CAN instance built from a HAL CAN …\nConfigure a single filter bank to accept all frames into …\nConsume the wrapper and get back the underlying HAL CAN …\nReturns the argument unchanged.\nAccess the underlying bxcan instance for advanced …\nCalls <code>U::from(self)</code>.\nCreate and enable a bxcan instance from a HAL CAN …\nBlocking receive of a frame.\nTransmit a data frame with a standard 11-bit ID.\nTransmit a pre-built CAN frame.\nConsume the wrapper and return the underlying timer …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInterpret the counter as a signed 32-bit position.\nInterpret the counter as a signed 16-bit position.\nRead the raw 16-bit counter value.\nRead the raw 32-bit counter value.\nReset the encoder position to zero.\nReset the encoder position to zero.\nConfigure TIM2 as a quadrature encoder with full 32-bit …\nConfigure TIM3 as a quadrature encoder with full 16-bit …\nWhether the LED is driven active-high or active-low on the …\nLED abstraction that remembers its active level and last …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an LED wrapper, initializing it to OFF.\nDrive the LED logically ON (true) or OFF (false).\nAll board pins. Construct this once at startup using:\nCAN1 bus pins\nCAN2 bus pins\nChip-select and digital I/O for DRV8873 drivers\nTIM2/TIM3 Quadrature Encoder Inputs\nSPI4 SCK/MISO/MOSI\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate all named pins from raw GPIO peripherals.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nManual chip-select line, active-low, generic over any GPIO …\nWrapper around an enabled HAL SPI instance (8-bit words).\nCreate an active-low chip select and set to the inactive …\nDeassert the chip select.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRead a byte, sending 0x00.\nAssert the chip select.\nPerform a blocking, full-duplex of one byte.\nTransfer a byte buffer in-place.\nSend a byte, ignoring the response.\nBlock until the hardware TX FIFO/drain is flushed.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWrite string and CRLF terminator.")