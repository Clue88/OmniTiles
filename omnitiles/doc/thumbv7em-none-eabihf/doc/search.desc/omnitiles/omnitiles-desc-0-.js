searchState.loadedDescShard("omnitiles", 0, "OmniTiles Firmware\nControl Algorithms\nDevice-Specific Drivers\nHardware Abstraction Layer (HAL‐level board support)\nActuator Abstractions\nClosed-loop controller for the linear lift actuator.\nGeneric PID controller for closed-loop control.\nMotor is manually disabled (coast).\nController state and configuration.\nOperating mode of the lift controller.\nRegular closed-loop control toward a height target.\nDirectly disable the lift (coast).\nRe-enable position control.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCurrent measured height (mm).\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new lift controller with PID gains and limits.\nReturns true if the lift is within tolerance of its …\nSet a new target height (mm), automatically clamped to …\nRun one control step.\nPID controller with tunable gains and output clamping.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new PID controller.\nReset integrator + derivative history.\nUpdate the controller.\nSet integral limits for anti-windup.\nSet output limits.\nMotor control over CAN for SteadyWin GIM6010-48 with a …\nDRV8873-Q1 SPI motor driver.\nMotor abstraction for DRV8873 SPI driver with a TIM2 …\nHigh-level CAN motor for a single driver instance, …\nError type for <code>CanMotor</code> operations.\nResponse frame contained no data bytes.\nDefault Pos_Max from the driver documentation, in units of …\nPayload too long for a single CAN data frame (max 8 bytes …\nReceive-side CAN error.\nTX mailbox or transmit failure.\nResponse had a different command code than expected.\nConvert a desired motor shaft angle in degrees to a raw …\nConvert a desired motor shaft angle in radians to a raw …\nClear any latched faults.\nTurn off motor output. The motor enters a free state and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new handle for this motor address.\nConvert a raw encoder value [0..65535] to a motor shaft …\nConvert a raw encoder value [0..65535] to a motor shaft …\nRead back the real-time motor speed in rpm.\nCommand the motor in speed control mode with a setpoint in …\nMaximum mechanical shaft angle in radians that the raw …\nDIAG status register.\nDRV8873 driver bound to a specific chip-select pin.\nFAULT status register.\nResponse of a single SPI transaction:\nStatus byte returned in the upper 8 bits of SDO.\nCharge-pump undervoltage fault condition.\nCharge-pump undervoltage fault condition.\nGlobal FAULT status register. Complements the nFAULT pin.\nRelease the chip-select pin.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCurrent regulation status of half bridge 1.\nCurrent regulation status of half bridge 2.\nConstruct a driver from an active-low chip-select pin.\nOvercurrent condition.\nOvercurrent condition.\nOvercurrent fault on the high-side FET of half bridge 1.\nOvercurrent fault on the high-side FET of half bridge 2.\nOvercurrent fault on the low-side FET of half bridge 1.\nOvercurrent fault on the low-side FET of half bridge 2.\nOpen-load detection on half bridge 1.\nOpen-load detection on half bridge 2.\nOpen-load detection.\nOpen-load detection.\nOvertemperature warning.\nOvertemperature warning.\nRead the DIAG register and parse into a <code>Diag</code> struct.\nRead the FAULT register and parse into a <code>Fault</code> struct.\nRead a register and return the response (status + register …\nSend a 16-bit word and receive the status + data bytes.\nOvercurrent shutdown.\nOvercurrent shutdown.\nUVLO fault condition.\nUVLO fault condition.\nWrite a register and return the response (status + current …\nLogical drive direction / mode for the H-bridge.\nMotor abstraction that combines a DRV8873 driver, four …\nApply PID output.\nApply brakes.\nCoast (this sets outputs to HiZ).\nDisable the motor and coast.\nAccess the underlying DRV8873 driver for advanced SPI …\nEnable the motor and wake the driver if in sleep.\nExpose the underlying encoder.\nMutable access to the encoder.\nDrive the motor forward.\nTear down this motor and return its constituent parts.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialize and set base configuration for the DRV8873.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new <code>SpiMotor</code>.\nEncoder position converted to revolutions.\nRaw encoder position in ticks (signed).\nRead the DIAG status register.\nRead the FAULT status register.\nDrive the motor in reverse.\nPut the driver into sleep mode.\nCompute a target tick position for a relative move in …\nCompute a target tick position for a relative move from …\nConvert a number of revolutions into encoder ticks.\nWake the driver from sleep mode.\nReset the encoder position to zero.\nController Area Network (CAN) abstraction layer.\nQuadrature encoder support via STM32F7 timers in encoder …\nLED abstraction layer.\nPin definitions for STM32F777 MCU for OmniTiles.\nPin definitions for the NUCLEO-F767ZI development board.\nSerial Peripheral Interface (SPI) abstraction layer.\nUSART abstraction layer.\nWrapper around a bxcan CAN instance built from a HAL CAN …\nConfigure a single filter bank to accept all frames into …\nConsume the wrapper and get back the underlying HAL CAN …\nReturns the argument unchanged.\nAccess the underlying bxcan instance for advanced …\nCalls <code>U::from(self)</code>.\nCreate and enable a bxcan instance from a HAL CAN …\nBlocking receive of a frame.\nTransmit a data frame with a standard 11-bit ID.\nTransmit a pre-built CAN frame.\nConsume the wrapper and return the underlying timer …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInterpret the counter as a signed 32-bit position.\nInterpret the counter as a signed 16-bit position.\nRead the raw 32-bit counter value.\nRead the raw 16-bit counter value.\nReset the encoder position to zero.\nReset the encoder position to zero.\nConfigure TIM2 as a quadrature encoder with full 32-bit …\nConfigure TIM3 as a quadrature encoder with full 16-bit …\nWhether the LED is driven active-high or active-low on the …\nLED abstraction that remembers its active level and last …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an LED wrapper, initializing it to OFF.\nDrive the LED logically ON (true) or OFF (false).\nAll board pins. Construct this once at startup using:\nCAN1 bus pins\nCAN2 bus pins\nChip-select and digital I/O for DRV8873 drivers\nTIM2/TIM3 Quadrature Encoder Inputs\nSPI4 SCK/MISO/MOSI\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate all named pins from raw GPIO peripherals.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nManual chip-select line, active-low, generic over any GPIO …\nWrapper around an enabled HAL SPI instance (8-bit words).\nCreate an active-low chip select and set to the inactive …\nDeassert the chip select.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRead a byte, sending 0x00.\nAssert the chip select.\nPerform a blocking, full-duplex of one byte.\nTransfer a byte buffer in-place.\nSend a byte, ignoring the response.\nBlock until the hardware TX FIFO/drain is flushed.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWrite string and CRLF terminator.\nLinear actuator interface built on top of <code>SpiMotor</code>.\nTilt actuator interface built on top of <code>CanMotor</code>.\nLift motor abstraction layered on top of a <code>SpiMotor</code>.\nApply PID output to the underlying motor.\nCompute a relative tick movement for a delta height.\nReturns the argument unchanged.\nCommand the lift to go to a specific height (mm), …\nConvert encoder ticks to millimeters of extension.\nExpose the underlying <code>SpiMotor</code>.\nCalls <code>U::from(self)</code>.\nMove by a relative number of millimeters.\nMove by a relative number of revolutions.\nCreate a new <code>LiftMotor</code> wrapper.\nCompute the target tick position for an absolute height …\nReset encoder reference (zero height).\nHigh-level tilt motor wrapped around a <code>CanMotor</code>.\nReturns the argument unchanged.\nAccess the underlying <code>CanMotor</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>TiltMotor</code> from an underlying <code>CanMotor</code> and a …\nConvert a desired motor shaft angle (degrees) into a raw …\nConvert a desired motor shaft angle (radians) into a raw …\nConvert a desired tile tilt angle in degrees into a raw …\nConvert a desired tile tilt angle in radians into a raw …\nConvert a raw encoder value [0..65535] into motor shaft …\nConvert a raw encoder value [0..65535] into motor shaft …\nConvert a raw encoder value into tile tilt angle in …\nConvert a raw encoder value into tile tilt angle in …")